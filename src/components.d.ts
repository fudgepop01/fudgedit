/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IRegion, NonLetter, SearchType } from "./components/hex-editor/interfaces";
import { ActiveMode } from "./components/tooltip/interfaces";
export { IRegion, NonLetter, SearchType } from "./components/hex-editor/interfaces";
export { ActiveMode } from "./components/tooltip/interfaces";
export namespace Components {
    interface HexEditor {
        /**
          * accepts and reads the given file, storing the result in the file variable
          * @param file
         */
        "acceptFile": (file: File) => Promise<void>;
        /**
          * weather or not to replace typical ASCII values with their ASCII value representation ( ex: 0x61 ==> ".a" )
          * @type {boolean}
          * @memberof HexEditor
         */
        "asciiInline": boolean;
        /**
          * the number of bits between separators on the bit display
          * @type {number}
          * @memberof HexEditor
         */
        "bitsPerGroup": number;
        /**
          * the number of chunks between separators
          * @type {number}
          * @memberof HexEditor
         */
        "bytesPerGroup": number;
        /**
          * the number of bytes to display per line
          * @type {number}
          * @memberof HexEditor
         */
        "bytesPerLine": number;
        /**
          * definitions for each chunk to display when displayAsChunks is enabled
          * @type {number[]}
          * @memberof HexEditor
         */
        "chunks": {
    title?: string;
    start: number;
    end: number;
  }[];
        /**
          * displays the file as chunks (defined above)
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayAsChunks": boolean;
        /**
          * weather or not to display ASCII on the side
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayAscii": boolean;
        /**
          * weather or not to display binary
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayBin": boolean;
        /**
          * weather or not to display Hex
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayHex": boolean;
        /**
          * the mode of data entry: insert:    inserts data between bytes overwrite:    overwrites the currently selected byte readonly:    no edits are possible
          * @type {("insert" | "overwrite" | "readonly")}
          * @memberof HexEditor
         */
        "editType": "insert" | "overwrite" | "readonly";
        /**
          * executes a search in the currently loaded file with the supplied parameters
          * @param text
          * @param searchType
          * @param range
          * @param searchByteCount
          * @param searchEndian
          * @memberof HexEditor
         */
        "executeSearch": (text: string, searchType: SearchType, range?: [number, number], searchByteCount?: 1 | 2 | 4 | 8, searchEndian?: 'big' | 'little') => Promise<number[]>;
        /**
          * fetches a Uint8Array of a given length at the given location
          * @param location where to fetch the data from
          * @param length how many bytes to load
          * @memberof HexEditor
         */
        "getChunk": (location: number, length: number) => Promise<{ out: Uint8Array; meta: { added: [number, number][]; }; }>;
        /**
          * returns the file's metadata
          * @memberof HexEditor
         */
        "getFileMetadata": () => Promise<File>;
        /**
          * the number of lines to display at once
          * @type {number}
          * @memberof HexEditor
         */
        "maxLines": number;
        /**
          * the mode of operation: region:    used to highlight different regions. Hovering over    a region displays a tooltip edit:    regions are displayed in the background, allowing    the user to edit directly noregion:    regions are not displayed at all
          * @type {("region" | "edit" | "noregion")}
          * @memberof HexEditor
         */
        "mode": "region" | "select" | "noregion";
        /**
          * What character to put in place of invalid ASCII
          * @memberof HexEditor
         */
        "nonDisplayCharacter": NonLetter;
        /**
          * How Opaque these invalid ASCII characters will be
          * @memberof HexEditor
         */
        "nonDisplayOpacity": number;
        /**
          * the number of regions to traverse
          * @type {number}
          * @memberof HexEditor
         */
        "regionDepth": number;
        /**
          * the region data. Data will be displayed in the tooltip if mode is set to "region"
          * @type {IRegion[]}
          * @memberof HexEditor
         */
        "regions": IRegion[];
        /**
          * returns the edited file
          * @returns 
          * @memberof HexEditor
         */
        "saveFile": () => Promise<Uint8Array | void>;
        /**
          * sets the new cursor position
          * @param newCursorPosition
          * @memberof HexEditor
         */
        "setCursorPosition": (newCursorPosition: number, bit?: number) => Promise<void>;
        /**
          * sets the line number
          * @param newLineNumber
          * @memberof HexEditor
         */
        "setLineNumber": (newLineNumber: number) => Promise<void>;
        /**
          * sets the new selection bounds.
          * @param newSelection
          * @memberof HexEditor
         */
        "setSelection": (newSelection: { start?: number; end?: number; startBit?: number; endBit?: number; }) => Promise<void>;
    }
    interface HexTooltip {
        "active": ActiveMode;
        "data": {[key: string]: string} | string;
        "simpleText": string;
    }
    interface MyComponent {
        /**
          * The first name
         */
        "first": string;
        /**
          * The last name
         */
        "last": string;
        /**
          * The middle name
         */
        "middle": string;
    }
    interface ToBionic {
    }
}
export interface HexEditorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLHexEditorElement;
}
declare global {
    interface HTMLHexEditorElement extends Components.HexEditor, HTMLStencilElement {
    }
    var HTMLHexEditorElement: {
        prototype: HTMLHexEditorElement;
        new (): HTMLHexEditorElement;
    };
    interface HTMLHexTooltipElement extends Components.HexTooltip, HTMLStencilElement {
    }
    var HTMLHexTooltipElement: {
        prototype: HTMLHexTooltipElement;
        new (): HTMLHexTooltipElement;
    };
    interface HTMLMyComponentElement extends Components.MyComponent, HTMLStencilElement {
    }
    var HTMLMyComponentElement: {
        prototype: HTMLMyComponentElement;
        new (): HTMLMyComponentElement;
    };
    interface HTMLToBionicElement extends Components.ToBionic, HTMLStencilElement {
    }
    var HTMLToBionicElement: {
        prototype: HTMLToBionicElement;
        new (): HTMLToBionicElement;
    };
    interface HTMLElementTagNameMap {
        "hex-editor": HTMLHexEditorElement;
        "hex-tooltip": HTMLHexTooltipElement;
        "my-component": HTMLMyComponentElement;
        "to-bionic": HTMLToBionicElement;
    }
}
declare namespace LocalJSX {
    interface HexEditor {
        /**
          * weather or not to replace typical ASCII values with their ASCII value representation ( ex: 0x61 ==> ".a" )
          * @type {boolean}
          * @memberof HexEditor
         */
        "asciiInline"?: boolean;
        /**
          * the number of bits between separators on the bit display
          * @type {number}
          * @memberof HexEditor
         */
        "bitsPerGroup"?: number;
        /**
          * the number of chunks between separators
          * @type {number}
          * @memberof HexEditor
         */
        "bytesPerGroup"?: number;
        /**
          * the number of bytes to display per line
          * @type {number}
          * @memberof HexEditor
         */
        "bytesPerLine"?: number;
        /**
          * definitions for each chunk to display when displayAsChunks is enabled
          * @type {number[]}
          * @memberof HexEditor
         */
        "chunks"?: {
    title?: string;
    start: number;
    end: number;
  }[];
        /**
          * displays the file as chunks (defined above)
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayAsChunks"?: boolean;
        /**
          * weather or not to display ASCII on the side
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayAscii"?: boolean;
        /**
          * weather or not to display binary
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayBin"?: boolean;
        /**
          * weather or not to display Hex
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayHex"?: boolean;
        /**
          * the mode of data entry: insert:    inserts data between bytes overwrite:    overwrites the currently selected byte readonly:    no edits are possible
          * @type {("insert" | "overwrite" | "readonly")}
          * @memberof HexEditor
         */
        "editType"?: "insert" | "overwrite" | "readonly";
        /**
          * the number of lines to display at once
          * @type {number}
          * @memberof HexEditor
         */
        "maxLines"?: number;
        /**
          * the mode of operation: region:    used to highlight different regions. Hovering over    a region displays a tooltip edit:    regions are displayed in the background, allowing    the user to edit directly noregion:    regions are not displayed at all
          * @type {("region" | "edit" | "noregion")}
          * @memberof HexEditor
         */
        "mode"?: "region" | "select" | "noregion";
        /**
          * What character to put in place of invalid ASCII
          * @memberof HexEditor
         */
        "nonDisplayCharacter"?: NonLetter;
        /**
          * How Opaque these invalid ASCII characters will be
          * @memberof HexEditor
         */
        "nonDisplayOpacity"?: number;
        /**
          * Emitted on the change of the cursor's position
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexCursorChanged"?: (event: HexEditorCustomEvent<any>) => void;
        /**
          * fired when the file's data changes
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexDataChanged"?: (event: HexEditorCustomEvent<any>) => void;
        /**
          * Emitted when the lineNumber changes
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexLineChanged"?: (event: HexEditorCustomEvent<any>) => void;
        /**
          * fired when the component loads
         */
        "onHexLoaded"?: (event: HexEditorCustomEvent<any>) => void;
        /**
          * Emitted when the selection changes
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexSelectionChanged"?: (event: HexEditorCustomEvent<any>) => void;
        /**
          * the number of regions to traverse
          * @type {number}
          * @memberof HexEditor
         */
        "regionDepth"?: number;
        /**
          * the region data. Data will be displayed in the tooltip if mode is set to "region"
          * @type {IRegion[]}
          * @memberof HexEditor
         */
        "regions"?: IRegion[];
    }
    interface HexTooltip {
        "active"?: ActiveMode;
        "data"?: {[key: string]: string} | string;
        "simpleText"?: string;
    }
    interface MyComponent {
        /**
          * The first name
         */
        "first"?: string;
        /**
          * The last name
         */
        "last"?: string;
        /**
          * The middle name
         */
        "middle"?: string;
    }
    interface ToBionic {
    }
    interface IntrinsicElements {
        "hex-editor": HexEditor;
        "hex-tooltip": HexTooltip;
        "my-component": MyComponent;
        "to-bionic": ToBionic;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "hex-editor": LocalJSX.HexEditor & JSXBase.HTMLAttributes<HTMLHexEditorElement>;
            "hex-tooltip": LocalJSX.HexTooltip & JSXBase.HTMLAttributes<HTMLHexTooltipElement>;
            "my-component": LocalJSX.MyComponent & JSXBase.HTMLAttributes<HTMLMyComponentElement>;
            "to-bionic": LocalJSX.ToBionic & JSXBase.HTMLAttributes<HTMLToBionicElement>;
        }
    }
}
